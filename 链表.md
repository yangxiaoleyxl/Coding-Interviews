## 链表
链表是一种同时具有迭代和递归特性的数据结构，针对链表相关的算法题，主要有两种思路：第一，**双指针方法**，典型的是快慢指针。第二，**递归**，利用链表的递归特性，可以实现反转链表，反转链表II。 
### 双指针解链表题 
- [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) 
```python 
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast = slow = head 
        while (fast != None and fast.next != None):
            slow = slow.next 
            fast = fast.next.next 
            if(fast == slow):break   

        if not (fast and fast.next): 
            return 

        slow = head 
        while(fast != slow):
            slow = slow.next 
            fast = fast.next 

        return slow 
``` 
- [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) 
```python
class Solution: 
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:   

        dummy = ListNode(-1) 
        dummy.next = head 
        x = self.FindFromEnd(dummy, n+1)  #  Find the last (n+1)th node  
        x.next = x.next.next 
        return dummy.next

    def FindFromEnd(self, head: ListNode, k:int) -> ListNode: 
        p1 = head 
        # k steps 
        for i in range(k): 
            p1 = p1.next  
        
        p2 = head 
        while p1 != None:
            p1 = p1.next 
            p2 = p2.next 

        return p2   
``` 
### 递归方法
- [ Reverse nodes in k group ]( https://leetcode.cn/problems/reverse-nodes-in-k-group/description/ )  
```python 
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:  
        if not head: return None
        a, b = head, head  

        for i in range(k): 
            if not b:
                return head
            b = b.next  

        new_head = self.reverse(a, b) 
        a.next = self.reverseKGroup(b, k) 

        return new_head

         
    def reverse(self, a, b): 
        pre, cur, nxt = None, a, a 
        while cur != b: 
            # nxt is the next node of cur
            nxt = cur.next  
            # reverse the LinkedList
            cur.next = pre  
            # pre, cur step forwards
            pre = cur  
            cur = nxt  

        return pre  
``` 

### 普通链表复制  
```python 
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:   
        if not head: return None 
        dum = pre = ListNode(0)  # create a virtual head for new linkedList  
        cur = head 
        while cur:
            new_node = ListNode(cur.value) # create a new node with current value in old linkedlist 
            pre.next = new_node # append new node to new linkedlist
            cur = cur.next # old list step forward 
            pre = new_node # new list step forward  

        return dum.next
```  

### 递归方法
- [ copy list with random pointer ]( https://leetcode.cn/problems/copy-list-with-random-pointer/description/ )  
```python 
class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':  
        if not head: return None 
        dic = {} 
        # 共遍历2次链表
        cur = head 
        while cur:
            dic[cur] = Node(cur.val) 
            cur = cur.next  
        # 第2次遍历链表
        cur = head 
        while cur:
            # 哈希表中找到cur.next 对应的结点,让 dic[cur].next 指向此 
            dic[cur].next = dic.get(cur.next)  
            # 哈希表中找到cur.random 对应的结点,让 dic[cur].random 指向此 
            dic[cur].random = dic.get(cur.random)  
            cur = cur.next  
        return dic[head] 
``` 


