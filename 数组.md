## 数组  
数组的考察是重点，通常有 **前缀和** 和 **差分** 技巧

- [ Longest consecutive sequence ]( https://leetcode.cn/problems/longest-consecutive-sequence/description/ )   
该题有两种思路，一种使用哈希表，一种是动态规划

```python 
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:   
        if not nums: return 0  
        
        nums = set(nums) 
        res = 0 
        for num in nums: 
            # left bound, process when num-1 does not exist
            if num-1 not in nums:   
                right = nums.get(num) 
                tmp = 1
                while num+1 in nums:  #  
                    num += 1
                    tmp += 1
                res = max(res, tmp) 
        return res    
```   

动态规划解法 
```python 
class Solution(object):
    def longestConsecutive(self, nums):
        hash_dict = dict()
        
        max_length = 0
        for num in nums:
            if num not in hash_dict:
                left = hash_dict.get(num - 1, 0)
                right = hash_dict.get(num + 1, 0)
                
                cur_length = 1 + left + right
                if cur_length > max_length:
                    max_length = cur_length
                
                hash_dict[num] = cur_length
                hash_dict[num - left] = cur_length
                hash_dict[num + right] = cur_length
                
        return max_length     
``` 

**前缀和**
- [ subarray sum equals k ]( https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked )   

```python 
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        # num_times 存储某“前缀和”出现的次数，这里用collections.defaultdict来定义它
        # 如果某前缀不在此字典中，那么它对应的次数为0
        num_times = collections.defaultdict(int)
        num_times[0] = 1  # 先给定一个初始值，代表前缀和为0的出现了一次
        cur_sum = 0  # 记录到当前位置的前缀和
        res = 0
        for i in range(len(nums)):
            cur_sum += nums[i]  # 计算当前前缀和
            if cur_sum - k in num_times:  # 如果前缀和减去目标值k所得到的值在字典中出现，即当前位置前缀和减去之前某一位的前缀和等于目标值
                res += num_times[cur_sum - k]
            # 下面一句实际上对应两种情况，一种是某cur_sum之前出现过（直接在原来出现的次数上+1即可），
            # 另一种是某cur_sum没出现过（理论上应该设为1，但是因为此处用defaultdict存储，如果cur_sum这个key不存在将返回默认的int，也就是0）
            # 返回0加上1和直接将其置为1是一样的效果。所以这里统一用一句话包含上述两种情况
            num_times[cur_sum] += 1
        return res    
```   


