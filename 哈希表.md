## Hash Map
- Hash maps are indexed data structures. A hash map makes use of a hash function to compute an index with a key into an array of buckets or slots. Its value is mapped to the bucket with the corresponding index. The key is unique and immutable. Think of a hash map as a cabinet having drawers with labels for the things stored in them 

- Memory index access takes constant time and hashing takes constant time. Hence, the search complexity of a hash map is also constant time, that is, <font color="red"> O(1) </font>

Important problems：
- [two sum](https://leetcode.com/problems/two-sum/)
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        tmp = {} 
        for idx, num in enumerate(nums):
            if target - num in tmp:  # 如果差值存在
                return [tmp[target-num], idx]   # 返回[差值的下标, 当前元素的下标] 
            #  如果不存在, tmp 中新增 k-v 
            tmp[nums[idx]] = idx 
        return [] 
```

- [Top k frequent elements]( https://leetcode.com/problems/top-k-frequent-elements/ )
```python
from collections import Counter  
import heapq 

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:  
        cnt = Counter(nums)  
        return heapq.nlargest(k, cnt.keys(), key=cnt.get)
```

- [ First Unique Character in a String ](https://leetcode.com/problems/first-unique-character-in-a-string/) 
```python
class Solution:
    def firstUniqChar(self, s: str) -> str: 
        rec = {}  
        for c in s:
            rec[c] = not c in rec  
        for k,v in rec.items():
            if v: return k 
        return ' ' 
```

- [ Group anagrams ]( https://leetcode.cn/problems/group-anagrams/description/ ) 
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:  
        table = {} 
        for s in strs:
            s_ = "".join(sorted(s))   
            if s_ not in table:
                table[s_] = [s] 
            else:
                table[s_].append(s) 
        return list(table.values())  
``` 

- [ Group anagrams ]( https://leetcode.cn/problems/group-anagrams/description/ ) 
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:  
        table = {} 
        for s in strs:
            s_ = "".join(sorted(s))   
            if s_ not in table:
                table[s_] = [s] 
            else:
                table[s_].append(s) 
        return list(table.values())  
```  

### 原地哈希方法的例子 
[ first missing positive ]( https://leetcode.cn/problems/first-missing-positive/description/ )  
思路:
- 要求使用常数级别的空间, 要找的数一定在 [1, N+1] 之间. **将原始数组当成哈希表来使用** 
- 将 <font color="red"> 数值为 i 的数放到下标为 i-1 的位置 </font>   
- 再遍历一遍数组, 遇到的 <font color="red"> 第一个值不等于下标的数 </font>    就是我们要找的那个
```python 
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:  
        # Regard the array as HashMap 
        for a in nums: #遍历每个座位，记当前坐着a号乘客
            while 0<a<=len(nums) and a!=nums[a-1]:  #乘客a是正票但坐错了! 其座位被 ta=nums[a-1]占了
                nums[a-1], a = a, nums[a - 1]  # a和ta两人互换则a对号入座。此后ta相当于新的a，去找自己的座位（循环执行）
        for i in range(len(nums)):
            if i+1 != nums[i]:
                return i+1  #找到首个没有对号入座的nums[i]!=i+1
        return len(nums)+1  #满座，返回N+1 
```    


[ first missing positive ]( https://leetcode.cn/problems/first-missing-positive/description/ )  
思路:
- 要求使用常数级别的空间, 要找的数一定在 [1, N+1] 之间. **将原始数组当成哈希表来使用** 
- 将 <font color="red"> 数值为 i 的数放到下标为 i-1 的位置 </font>   
- 再遍历一遍数组, 遇到的 <font color="red"> 第一个值不等于下标的数 </font>    就是我们要找的那个
```python 
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:  
        # Regard the array as HashMap 
        for a in nums: #遍历每个座位，记当前坐着a号乘客
            while 0<a<=len(nums) and a!=nums[a-1]:  #乘客a是正票但坐错了! 其座位被 ta=nums[a-1]占了
                nums[a-1], a = a, nums[a - 1]  # a和ta两人互换则a对号入座。此后ta相当于新的a，去找自己的座位（循环执行）
        for i in range(len(nums)):
            if i+1 != nums[i]:
                return i+1  #找到首个没有对号入座的nums[i]!=i+1
        return len(nums)+1  #满座，返回N+1 
```  
