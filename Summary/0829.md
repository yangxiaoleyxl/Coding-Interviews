## 0829 
### 算法题复习 
1.两数之和: 
```python
for id, num in enumerate(nums):
    if target-num in dic: 
        return [dic[target-num], id] 
    else: 
        dic[num] = id  
```    


2.括号生成 
```python  
path = '' 
res = []  

if left == 0 and right == 0:
    res.append(path) 
    return 
        # if left > 0 : 
        #     self.backtrack(left-1, right, res, path+'(')
        # if left < right: 
        #     self.backtrack(left, right-1, res, path+')')  
    if left > right: return
    if left<0 or right<0: return 
    path += '('
    self.backtrack(left-1, right, res, path) 
    path = path[:-1]  

    path += ')'
    self.backtrack(left, right-1, res, path) 
    path = path[:-1] 
```   

3.缺失的第一个正数 
```python 
n = len(nums)
for a in nums: 
    if 0<a<=n and a != nums[a-1]:
        num[a-1], a-1 = a, nums[a] 

# 再遍历整个数组
for i in range(n):
    if i+1 != nums[i]:
        return i+1 
return len(nums)+1 
```  

### 算法题新增  
1.岛屿数量  
```python
# 网格类问题的 DFS 解法 
def inArea(grid, r, c):
    return 0<=r and r<len(grid) and 0<=c and c < len(grid[0]) 
def dfs(grid, r, c): 
    if not grid: return 
    if grid[r][c] != '1':
        return 
    # 将遍历过的陆地节点置为‘2’, 注意不是 == 判定是否为‘2’ 
    grid[r][c] = '2' 
    dfs(grid, r-1, c)
    dfs(grid, r+1, c)
    dfs(grid, r, c-1)
    dfs(grid, r, c+1)  

cnt = 0  
for i in range(len(grid)):
    for j in range(len(grid[0])):
        if grid[i][j] == 1:
            dfs(grid, i, j) 
            cnt += 1
return cnt 

``` 

2.下一个最大排列 
```python

```

### 风控/ML八股文复习   
- k-meams算法的具体步骤 
- K-means++算法的改进之处 
- DBSCAN的具体实现步骤

### 风控/ML八股文新增  
- 逻辑回归评分卡模型 
    - 
- 评分卡模型为什么要用 WOE
- WOE 为什么要用 In 
- XGBOOST 的公式推导 
    - 损失函数
    - 泰勒公式
    - 正则项 
- XGB与LR/LGB/RF/GBDT的差异 