## 0829 
### 算法题复习
1. 反转链表 
```python  
# 递归方法    

def reverse(head):
    if not head:
        return   
    last = reverse(head.next) 
    head.next.next = head 
    head.next = None 
    return last 

# 迭代方法 
# 反转链表两个指针不够, 需要三个指针, pre, cur, nxt  
pre = None 
cur = head.next 
while cur:  
    nxt = cur.next # 暂存原next, 否则会丢失  
    cur.next = pre # 反转 
    pre = cur # 新头变旧头 
    cur = nxt # 暂存的旧头 变 新头 
```   
2. 反转链表II   
- 迭代方法, 需要在反转部分前面加一个 **哨兵** 节点 
```python 
dummy = ListNode(next=head)
p0 = dummy   

for _ in range(left-1): 
    # 推进到待反转部分的前一个节点 
    p0 = p0.next 

# 与 ‘反转链表’ 相同 
pre = None 
cur = p0.next # p0 相当于头 

for j in range(right-left+1): 
    nxt = cur.next 
    cur.next = pre 
    pre = cur 
    cur = nxt 

p0.next.next = cur 
p0.next = pre 

```   

### 算法题新增 
打家劫舍 
- 一维DP问题, `dp[i]`定义为 **在第i间房及以前可获得的偷取的最大金额**
- 拆解: <font color="red"> 偷不偷第i间房 </font>, **偷, dp[i] = 上上间房可偷得最大金额 + 本间房可偷金额** , **不偷, dp[i] = dp[i-1] **  
- 状态转移方程 ` dp[i] = max(dp[i-2] + nums[i], dp[i-1]) `    

```python  
# 数组DP  
if not nums: return 0 
if len(nums) == 1: return nums[0] 

# 由于dp[i] 只和 dp[i-1], dp[i-2] 有关, 因此使用 一维数组 进行空间优化 
pre, cur = 0, 0 
for num in nums: # 遍历房间(背包容量) 
    pre, cur = cur, max(pre+num, cur) 
return cur  

```  



### 风控/ML八股文复习  
- 

### 风控/ML八股文新增 
- LGB的特点 
- 特征工程
    - 特征衍生(常见特征衍生方案)
    - 特征选择(可解释性,稳定性) 
    - 特征分箱方法 