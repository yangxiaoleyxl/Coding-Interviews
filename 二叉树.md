## 二叉树 （Binary Tree）  
### 常见的二叉树：
- 满二叉树： 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树
- 完全二叉树：一棵二叉树**至多只有最下面的一层上的结点的度数可以小于2**，并且最下层上的结点都集中在该层最左边的若干位置上 
- 二叉搜索树：一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则**左子树上所有结点的值均小于它的根结点的值**； 若它的右子树不空，则**右子树上所有结点的值均大于它的根结点的值**；它的左、右子树也分别为二叉排序树  
- 平衡二叉树（AVL树）：<font color="red"> 解决二叉树退化成一棵链表而诞生的 </font>，一棵空树或**它的左右两个子树的高度差的绝对值不超过1**，并且左右两个子树都是一棵平衡二叉树  
- 红黑树：对于那种频繁删除、插入的场景，平衡二叉树的调整过程显然是存在性能问题的，所以为了解决这个问题，进而又引入了红黑树。红黑树的特点：
    - 具有二叉树所有特点。
    - 每个节点只能是红色或者是黑色。
    - 根节点只能是黑色，且黑色根节点不存储数据。
    - 任何相邻的节点都不能同时为红色。
    - 红色的节点，它的子节点只能是黑色。
    - 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点  

概括为：
- **红黑树所有的根节点都是黑色的的空节点，也就是根节点不存数据**；
- **任何相邻的节点都不能同时为红色，红色节点是被黑色节点隔开的，每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点** 

正是因为这种特点，红黑树不同于平衡树的操作，<font color="red"> 红黑树不会因为插入、删除等操作追求绝对的平衡，它的旋转次数少，插入最多两次旋转，删除最多三次旋转 </font>，所以对于搜索、插入、删除操作较多的情况下，红黑树的效率是优于平衡二叉树的  

### 二叉树，单链表及数组的关系
单链表和数组的遍历可以是迭代的，也可以是递归的，**二叉树这种结构无非就是二叉链表**，由于没办法简单改写成迭代形式，所以一般说**二叉树的遍历框架都是指递归的形式**。

只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。所谓 <font color="red"> 前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候 </font> 

### 对前中后序遍历的理解 

**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，
前序位置的代码 <font color="red"> 在刚刚进入一个二叉树节点的时候执行 </font>；后序位置的代码在  <font color="red"> 将要离开一个二叉树节点的时候执行 </font>；中序位置的代码在 <font color="red"> 一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行 </font> 

```python 
def traverse(root):
    if root is None:
        return
    # 前序位置
    traverse(root.left)
    # 中序位置
    traverse(root.right)
    # 后序位置

```

因此，关于二叉树本质的理解可以是这样:
二叉树的所有问题，就是让你**在前中后序位置注入巧妙的代码逻辑**，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作

### 二叉树类型题目：
本质上，二叉树对应着许多算法的底层实现逻辑，例如， <font color="red"> 快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历 </font>。解决二叉树类型的题目可以分为两类思路，一种是**回溯算法框架**，一种是**动态规划框架** 

- [ Diameter of Binary Tree ]( https://leetcode.cn/problems/diameter-of-binary-tree/description/ ) 
```python
class Solution:
    def __init__(self):
        # 记录最大直径的长度
        self.maxDiameter = 0

    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        # 对每个节点计算直径，求最大直径
        self.traverse(root)
        return self.maxDiameter

    # 遍历二叉树
    def traverse(self, root: TreeNode) -> None:
        if not root:
            return
        # 对每个节点计算直径
        leftMax = self.maxDepth(root.left)
        rightMax = self.maxDepth(root.right)
        myDiameter = leftMax + rightMax
        # 更新全局最大直径
        self.maxDiameter = max(self.maxDiameter, myDiameter)
        
        self.traverse(root.left)
        self.traverse(root.right)

    # 计算二叉树的最大深度
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        leftMax = self.maxDepth(root.left)
        rightMax = self.maxDepth(root.right)
        return max(leftMax, rightMax) + 1 
``` 

- [ Maximum Depth of Binary Tree ]( https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/ ) 
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:  
        if root == None:
            return 0 

        leftHeight = self.maxDepth(root.left) 
        rightHeight = self.maxDepth(root.right) 

        return max(leftHeight, rightHeight) + 1  
``` 

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:  
        if root == None:
            return 0 

        leftHeight = self.maxDepth(root.left) 
        rightHeight = self.maxDepth(root.right) 

        return max(leftHeight, rightHeight) + 1 
```





-  
- 