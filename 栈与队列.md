### 栈与队列  
Coding Interview 主要考察利用栈实现队列，用队列实现栈等问题。此外，还考察单调栈，单调队列的应用。在使用Python刷题时, 内置库 `collections` 的子类 `Counter` ,`deque`, `queue` 的子类 `Queue()`, `LifoQueue()` 和 `PriorityQueue()` 

经典题目： 

- [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)
- [Container With Most Water](https://leetcode.com/problems/container-with-most-water/)
- [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)
- [3Sum](https://leetcode.com/problems/3sum/)

1. [ Sliding window maximum ]( https://leetcode.cn/problems/sliding-window-maximum/ )    
```python       
``` 

2. [队列的最大值](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/) 
```python 
import queue  
class MaxQueue:
    """ 2数组 """
    def __init__(self):
        # self.max_stack 是一个辅助栈，其栈顶元素永远是最大值
        self.queue = [] 
        self.max_stack = [] 

    def max_value(self) -> int: 
        return self.max_stack[0] if self.max_stack else -1 

    def push_back(self, value: int) -> None: 
        self.queue.append(value)   #  新元素插入队尾 

        # 比较 新元素 和 max_stack 队尾元素  
        while self.max_stack and self.max_stack[-1] < value :
            self.max_stack.pop()   #  
        self.max_stack.append(value)

    def pop_front(self) -> int: 
        if not self.queue: return -1 
        ans = self.queue.pop(0) 

        if ans == self.max_stack[0]:
            self.max_stack.pop(0) 
        return ans   

# Your MaxQueue object will be instantiated and called as such:
# obj = MaxQueue()
# param_1 = obj.max_value()
# obj.push_back(value)
# param_3 = obj.pop_front()
``` 
3. [Remove elements](https://leetcode.cn/problems/remove-element/description/)    
```python 
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:  
        slow = 0
        fast = 0 
        while fast < len(nums):
            if nums[fast] != val :
                nums[slow] =nums[fast] 
                slow += 1 
            fast += 1 
        
        return slow 
``` 
4. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)   
```python 
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int: 
        if not nums:
            return 
        slow = 0 
        fast = 1
        while fast < len(nums):  
            if nums[slow] != nums[fast]: 
                slow += 1   
                nums[slow] = nums[fast]    
            fast += 1     
        return slow + 1 
```
5. [Remove-nth-node-from-end-of-list](https://leetcode.cn/problems/remove-nth-node-from-end-of-list)    
```python 
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:  
        slow = 0
        fast = 0 
        while fast < len(nums):
            if nums[fast] != val :
                nums[slow] =nums[fast] 
                slow += 1 
            fast += 1 
        
        return slow 
```
6. [3Sum](https://leetcode.cn/problems/3sum)    
```python 
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:   
        nums.sort()
    
        # initialize the result list
        res = []
        
        # iterate over the array
        for i in range(len(nums)):
            # skip over duplicates
            if i > 0 and nums[i] == nums[i-1]:
                continue
            
            # initialize the two pointers
            left = i + 1
            right = len(nums) - 1
            
            # iterate over the remaining elements
            while left < right:
                # calculate the sum of the three elements
                total = nums[i] + nums[left] + nums[right]
                
                # if the sum is less than zero, move the left pointer to the right
                if total < 0:
                    left += 1
                # if the sum is greater than zero, move the right pointer to the left
                elif total > 0:
                    right -= 1
                # if the sum is zero, add the triplet to the result list and move both pointers
                else:
                    res.append([nums[i], nums[left], nums[right]])
                    left += 1
                    right -= 1
                    
                    # skip over duplicates
                    while left < right and nums[left] == nums[left-1]:
                        left += 1
                    while left < right and nums[right] == nums[right+1]:
                        right -= 1
        
        return res 
```
7. [链表中倒数第 K 个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)    
```python 
class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode: 
        fast = head 

        for i in range(k): 
            fast = fast.next 

        slow = head 
        while fast : 
            slow = slow.next
            fast = fast.next 
        
        return slow
``` 
