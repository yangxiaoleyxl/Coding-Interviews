## 动态规划（Dynamic Programming）  
动态规划问题的一般形式就是求最值, 动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列，最小编辑距离等等  

求解动态规划的核心问题是**穷举**. 动态规划需要熟练掌握**递归**思维，只有列出正确的「状态转移方程」，才能正确地穷举。而且，你需要判断算法问题是否具备「最优子结构」，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题存在「重叠子问题」，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算 

DP的三要素：
- 重叠子问题
- 最优子结构
- 状态转移方程

解决动态规划的思维框架是:
<font color="red"> 明确base case -> 明确[状态] -> 明确[选择] -> 定义 dp 数组/函数 </font>  

伪代码模板如下:
```python 
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```
- [ Coin Change ]( https://leetcode.cn/problems/coin-change/ )  
```python 
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        
        n = len(coins)
        dp = [[amount+1] * (amount+1) for _ in range(n+1)]    # 初始化为一个较大的值，如 +inf 或 amount+1
        # 合法的初始化
        dp[0][0] = 0    # 其他 dp[0][j]均不合法
        
        # 完全背包：套用0-1背包【遍历硬币数目k】
        for i in range(1, n+1):                     # 第一层循环：遍历硬币
            for j in range(amount+1):               # 第二层循环：遍历背包
                for k in range(j//coins[i-1]+1):    # 第三层循环：当前硬币coin取k个 (k*coin<=amount)
                    dp[i][j] = min( dp[i][j], dp[i-1][j-k*coins[i-1]] + k )

        ans = dp[n][amount] 
        return ans if ans != amount+1 else -1
```  

递归算法的时间复杂度如何计算
- 用子问题个数 $ \times $ 解决一个子问题需要的时间 
- 


常见的动态规划问题
- 0-1背包问题 
- 完全背包问题 
一般背景：我们有 $n$ 件物品和一个容量为$C$的背包，记第i件物品的重量为 $g$, 价值为 $V$，求将哪些物品装入背包可使价值总和最大 
- 0-1背包问题：**每件物品最多取1次**
- 完全背包：**每件物品最多取无限次** 

「0−1 背包问题」

一般地，我们定义：dp[i][j]dp[i][j]dp[i][j] 表示前 iii 件物品放入一个容量为 jjj 的背包可以获得的最大价值（每件物品最多放一次），则状态转移过程可表示为：

不选择第 iii 件物品，则问题转化为了前 i−1i-1i−1 件物品放入容量为 jjj 的背包中所获得的价值：dp[i][j]=dp[i−1][j]dp[i][j] =dp[i-1][j]dp[i][j]=dp[i−1][j] ；
选择第 iii 件物品，则问题转化为了前 i−1i-1i−1 件物品放入容量为 j−wij-w_ij−w 
i
​
  的背包中所获得的价值 dp[i−1][j−wi]dp[i-1][j-w_i]dp[i−1][j−w 
i
​
 ] 加上要放入的第 iii 件物品的价值 viv_iv 
i
​
 ：dp[i][j]=dp[i−1][j−wi]+vidp[i][j] =dp[i-1][j-w_i] + v_idp[i][j]=dp[i−1][j−w 
i
​
 ]+v 
i
​
  。注意，能放入第 iii 件物品的前提为：wi≤jw_i \leq jw 
i
​
 ≤j。
两种情况取较大者即可得到「状态转移方程」为

作者：flix
链接：https://leetcode.cn/problems/coin-change/solutions/1412324/by-flix-su7s/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。







