## 动态规划（Dynamic Programming）  
动态规划问题的一般形式就是求最值, 动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列，最小编辑距离等等  

求解动态规划的核心问题是**穷举**. 动态规划需要熟练掌握**递归**思维，只有列出正确的「状态转移方程」，才能正确地穷举。而且，你需要判断算法问题是否具备「最优子结构」，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题存在「重叠子问题」，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算 

DP的三要素：
- 重叠子问题
- 最优子结构
- 状态转移方程

解决动态规划的思维框架是:
<font color="red"> 明确base case -> 明确[状态] -> 明确[选择] -> 定义 dp 数组/函数 </font>  

伪代码模板如下:
```python 
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```
- [ Coin Change ]( https://leetcode.cn/problems/coin-change/ )  
```python 
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        
        n = len(coins)
        dp = [[amount+1] * (amount+1) for _ in range(n+1)]    # 初始化为一个较大的值，如 +inf 或 amount+1
        # 合法的初始化
        dp[0][0] = 0    # 其他 dp[0][j]均不合法
        
        # 完全背包：套用0-1背包【遍历硬币数目k】
        for i in range(1, n+1):                     # 第一层循环：遍历硬币
            for j in range(amount+1):               # 第二层循环：遍历背包
                for k in range(j//coins[i-1]+1):    # 第三层循环：当前硬币coin取k个 (k*coin<=amount)
                    dp[i][j] = min( dp[i][j], dp[i-1][j-k*coins[i-1]] + k )

        ans = dp[n][amount] 
        return ans if ans != amount+1 else -1
```  

递归算法的时间复杂度如何计算
- 用子问题个数 $ \times $ 解决一个子问题需要的时间 


常见的动态规划问题
- 背包问题 

一般背景：我们有 $n$ 件物品和一个容量为 $C$ 的背包，记第i件物品的重量为 $g$, 价值为 $V$，求将哪些物品装入背包可使价值总和最大 

0-1背包问题 ：<font color="red">**每件物品最多取1次**</font>。
完全背包问题 ：<font color="red"> **每件物品最多取无限次**  </font>。组合背包问题 ：<font color="red">**背包中物品要考虑顺序**</font>。分组背包问题 ：<font color="red"> **不止一个背包，需要遍历每个背包**  </font>。 

目标也有所不同，分为以下几类：
- 最值问题：求最大/最下值
- 存在问题：是否存在...，满足...
- 组合问题: 求所有满足...的排列组合 




「0−1 背包问题」

一般地，我们定义：$dp[i][j]$ 表示前 $i$ 件物品放入一个容量为 $j$ 的背包可以获得的最大价值（每件物品最多放一次），则状态转移过程可表示为： 
- **不选择** 第 $i$ 件物品，则问题转化为 **前$i-1$件物品**放入容量为 $j$ 的背包中所获得的价值： $ dp[i][j]=dp[i-1][j] $  
- **选择** 第 $i$ 件物品，则问题转化为 **前 $i-1$件物品放入容量为 $j-w_i$** 背包中所获得的价值 $dp[i-1][j-w_i]$ 加上要放入的第 $i$ 件物品的价值 $v_i$ : $ dp[i][j] = dp[i-1][j-w_i] + v_i$ 

两种情况取较大者，可以获得 **状态转移方程**：
$$
dp[i][j] = max\{ dp[i-1][j], dp[i-1][j-w_i]+v_i \}
$$     

关于 0-1 背包问题，根据状态转移方程得到的代码如下：
```python 
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        n = len(coins) 
        dp = [[amounts+1] * (amount+1) for _ in range(n+1)] 
        dp[0][0] = 0

        n = len(coins)
        dp = [[amount+1] * (amount+1) for _ in range(n+1)]    # 初始化为一个较大的值，如 +inf 或 amount+1
        # 合法的初始化
        dp[0][0] = 0    # 其他 dp[0][j]均不合法
        
        # 完全背包：优化后的状态转移
        for i in range(1, n+1):             # 第一层循环：遍历物品
            for j in range(amount+1):       # 第二层循环：遍历背包
                if j < coins[i-1]:          # 容量有限，无法选择第i种物品
                    dp[i][j] = dp[i-1][j]
                else:                       # 可选择第i种物品
                    dp[i][j] = min( dp[i-1][j], dp[i][j-coins[i-1]] + 1 )

        ans = dp[n][amount] 
        return ans if ans != amount+1 else -1
```  

进一步优化  
```python 
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        n = len(coins) 
        dp = [[amounts+1] * (amount+1) for _ in range(n+1)] 
        dp[0][0] = 0

        n = len(coins)
        dp = [[amount+1] * (amount+1) for _ in range(n+1)]    # 初始化为一个较大的值，如 +inf 或 amount+1
        # 合法的初始化
        dp[0][0] = 0    # 其他 dp[0][j]均不合法
        
        # 完全背包：优化后的状态转移
        for i in range(1, n+1):             # 第一层循环：遍历物品
            for j in range(amount+1):       # 第二层循环：遍历背包
                if j < coins[i-1]:          # 容量有限，无法选择第i种物品
                    dp[i][j] = dp[i-1][j]
                else:                       # 可选择第i种物品
                    dp[i][j] = min( dp[i-1][j], dp[i][j-coins[i-1]] + 1 )

        ans = dp[n][amount] 
        return ans if ans != amount+1 else -1
```  
因为,  每一行的 $dp[i][j]$ 状态值只与上一行（正上方）$dp[i-1][j]$ 和本行（左方）的 $dp[i][j-*]$ 有关, 因此**可基于滚动数组的思想**进行对状态空间进行优化而省去第一维度 
```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        
        n = len(coins)
        dp = [amount+1] * (amount+1)    # 初始化为一个较大的值，如 +inf 或 amount+1
        dp[0] = 0        # 合法的初始化
        
        # 完全背包：优化后的状态转移
        for i in range(1, n+1):             # 第一层循环：遍历硬币
            dp2 = [amount+1] * (amount+1)   # 滚动数组
            for j in range(amount+1):       # 第二层循环：遍历背包
                if j < coins[i-1]:          # 容量有限，无法选择第i种硬币
                    dp2[j] = dp[j]
                else:                       # 可选择第i种硬币
                    dp2[j] = min( dp[j], dp2[j-coins[i-1]] + 1 )
            dp = dp2

        ans = dp[amount] 
        return ans if ans != amount+1 else -1
``` 
还可以进一步优化，只保留 **代表剩余容量** 的维度。在状态转移过程中，每一行的状态值都**只与其正上方和左方**的状态值有关，因此可对状态空间进一步优化而**省去滚动数组**，在更新 $dp[j]$ 时，仅使用了上行的$dp[j]$ 和本行的 $dp[j-w_i]$  
```python 
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        
        dp = [amount+1] * (amount+1)    # 初始化为一个较大的值，如 +inf 或 amount+1
        dp[0] = 0        # 合法的初始化；其他 dp[j]均不合法
        
        # 完全背包：优化后的状态转移
        for coin in coins:                      # 第一层循环：遍历硬币
            for j in range(coin, amount+1):     # 第二层循环：遍历背包【正序】
                dp[j] = min( dp[j], dp[j-coin] + 1 )    # 可选择当前硬币

        ans = dp[amount] 
        return ans if ans != amount+1 else -1
```



常见动态规划问题： 
- [ Fibonacci Number ]( https://leetcode.cn/problems/fibonacci-number/description/ ) 
```python 
class Solution:
    def fib(self, n: int) -> int:  
        if n == 0: return 0 
        dp = [0] * (n+1) 
        # base case 
        dp[0], dp[1] = 0, 1  

        for i in range(2, n+1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]  
```    

- [ Coin Change ]( https://leetcode.cn/problems/coin-change/description/ )   
```python 
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int: 
        n = len(coins) 

        # 初始化为一个较大的值
        dp = [ [amount+1] + [amount+1] for _ in range(n+1) ]  
        # 合法初始化
        dp[0][0] = 0 

        # 完全背包
        for i in range(1, n+1): # 遍历硬币
            for j in range(amount+1): 
                # 遍历背包  
                if j < coins[i-1]: # 若容量有限，无法选择第i种硬币
                    dp[i][j] = dp[i-1][j]  
                else:
                    dp[i][j] = min( dp[i-1][j], dp[i][j-coins[i-1]] + 1)  
``` 
