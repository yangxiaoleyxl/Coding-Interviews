## 动态规划（Dynamic Programming）  
### 基本概念
动态规划问题的一般形式就是求最值, 动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列，最小编辑距离等等  

求解动态规划的核心问题是**穷举**. 动态规划需要熟练掌握**递归**思维，只有列出正确的「状态转移方程」，才能正确地穷举。而且，你需要判断算法问题是否具备「最优子结构」，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题存在「重叠子问题」，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算 

DP的三要素：
- 重叠子问题
- 最优子结构
- 状态转移方程

解决动态规划的思维框架是:
<font color="red"> 明确base case -> 明确[状态] -> 明确[选择] -> 定义 dp 数组/函数 </font>  

伪代码模板如下:
```python 
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```
- [ Coin Change ]( https://leetcode.cn/problems/coin-change/ )  
```python 
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        
        n = len(coins)
        dp = [[amount+1] * (amount+1) for _ in range(n+1)]    # 初始化为一个较大的值，如 +inf 或 amount+1
        # 合法的初始化
        dp[0][0] = 0    # 其他 dp[0][j]均不合法
        
        # 完全背包：套用0-1背包【遍历硬币数目k】
        for i in range(1, n+1):                     # 第一层循环：遍历硬币
            for j in range(amount+1):               # 第二层循环：遍历背包
                for k in range(j//coins[i-1]+1):    # 第三层循环：当前硬币coin取k个 (k*coin<=amount)
                    dp[i][j] = min( dp[i][j], dp[i-1][j-k*coins[i-1]] + k )

        ans = dp[n][amount] 
        return ans if ans != amount+1 else -1
```  

递归算法的时间复杂度如何计算
- 用子问题个数 $ \times $ 解决一个子问题需要的时间  

### 重要思路
- 动态规划穷举的两种视角
    - 关于排列组合，**都可以抽象成[球盒模型]** 
    - 从**球选盒**的角度，$P(n,k) = P(n-1,k) + kP(n-1, k-1)$ 
    - 从**盒选球**的角度，$P(n,k)=nP(n-1,k-1)$
- **子序列问题**可以从上述两个视角取看
    - 定义状态：$dp[i][j]$代表  $s[:j]$中匹配$t[:i]$ 的个数 
    - 边界条件：$dp[0][j]=1$
    - 状态转移方程（发掘重叠子问题）：
        - $s[j-1] == t[i-1]$, 可选择保留或不保留$s[j-1]$, 若保留，则有$dp[i-1][j-1]$个；若不保留，则有$dp[i-1][j]$个 

综上，用代码表示：
```python 
if s[i-1]==t[j-1]:
    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
else:
    dp[i][j] = dp[i-1][j] 
``` 

对上述DP状态转移方程还可以使用**滚动数组优化**
解决两个字符串的动态规划问题，<font color="red">**一般都是用两个指针 i, j 分别指向两个字符串的最后，然后一步步往前移动，缩小问题的规模**</font>


### 常见的动态规划问题
- 背包问题 

一般背景：我们有 $n$ 件物品和一个容量为 $C$ 的背包，记第i件物品的重量为 $g$, 价值为 $V$，求将哪些物品装入背包可使价值总和最大 

0-1背包问题 ：<font color="red">**每件物品最多取1次**</font>。
完全背包问题 ：<font color="red"> **每件物品最多取无限次**  </font>。组合背包问题 ：<font color="red">**背包中物品要考虑顺序**</font>。分组背包问题 ：<font color="red"> **不止一个背包，需要遍历每个背包**  </font>。 

目标也有所不同，分为以下几类：
- 最值问题：求最大/最下值
- 存在问题：是否存在...，满足...
- 组合问题: 求所有满足...的排列组合 

「0−1 背包问题」

一般地，我们定义：$dp[i][j]$ 表示前 $i$ 件物品放入一个容量为 $j$ 的背包可以获得的最大价值（每件物品最多放一次），则状态转移过程可表示为： 
- **不选择** 第 $i$ 件物品，则问题转化为 **前$i-1$件物品**放入容量为 $j$ 的背包中所获得的价值： $ dp[i][j]=dp[i-1][j] $  
- **选择** 第 $i$ 件物品，则问题转化为 **前 $i-1$件物品放入容量为 $j-w_i$** 背包中所获得的价值 $dp[i-1][j-w_i]$ 加上要放入的第 $i$ 件物品的价值 $v_i$ : $ dp[i][j] = dp[i-1][j-w_i] + v_i$ 

两种情况取较大者，可以获得 **状态转移方程**：
$$
dp[i][j] = max\{ dp[i-1][j], dp[i-1][j-w_i]+v_i \}
$$     

关于 0-1 背包问题，根据状态转移方程得到的代码如下：
```python 
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        n = len(coins) 
        dp = [[amounts+1] * (amount+1) for _ in range(n+1)] 
        dp[0][0] = 0

        n = len(coins)
        dp = [[amount+1] * (amount+1) for _ in range(n+1)]    # 初始化为一个较大的值，如 +inf 或 amount+1
        # 合法的初始化
        dp[0][0] = 0    # 其他 dp[0][j]均不合法
        
        # 完全背包：优化后的状态转移
        for i in range(1, n+1):             # 第一层循环：遍历物品
            for j in range(amount+1):       # 第二层循环：遍历背包
                if j < coins[i-1]:          # 容量有限，无法选择第i种物品
                    dp[i][j] = dp[i-1][j]
                else:                       # 可选择第i种物品
                    dp[i][j] = min( dp[i-1][j], dp[i][j-coins[i-1]] + 1 )

        ans = dp[n][amount] 
        return ans if ans != amount+1 else -1
```  

进一步优化 

```python 
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        n = len(coins) 
        dp = [[amounts+1] * (amount+1) for _ in range(n+1)] 
        dp[0][0] = 0

        n = len(coins)
        dp = [[amount+1] * (amount+1) for _ in range(n+1)]    # 初始化为一个较大的值，如 +inf 或 amount+1
        # 合法的初始化
        dp[0][0] = 0    # 其他 dp[0][j]均不合法
        
        # 完全背包：优化后的状态转移
        for i in range(1, n+1):             # 第一层循环：遍历物品
            for j in range(amount+1):       # 第二层循环：遍历背包
                if j < coins[i-1]:          # 容量有限，无法选择第i种物品
                    dp[i][j] = dp[i-1][j]
                else:                       # 可选择第i种物品
                    dp[i][j] = min( dp[i-1][j], dp[i][j-coins[i-1]] + 1 )

        ans = dp[n][amount] 
        return ans if ans != amount+1 else -1
```   

因为,  每一行的 $dp[i][j]$ 状态值只与上一行（正上方）$dp[i-1][j]$ 和本行（左方）的 $dp[i][j-*]$ 有关, 因此**可基于滚动数组的思想**进行对状态空间进行优化而省去第一维度  

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        
        n = len(coins)
        dp = [amount+1] * (amount+1)    # 初始化为一个较大的值，如 +inf 或 amount+1
        dp[0] = 0        # 合法的初始化
        
        # 完全背包：优化后的状态转移
        for i in range(1, n+1):             # 第一层循环：遍历硬币
            dp2 = [amount+1] * (amount+1)   # 滚动数组
            for j in range(amount+1):       # 第二层循环：遍历背包
                if j < coins[i-1]:          # 容量有限，无法选择第i种硬币
                    dp2[j] = dp[j]
                else:                       # 可选择第i种硬币
                    dp2[j] = min( dp[j], dp2[j-coins[i-1]] + 1 )
            dp = dp2

        ans = dp[amount] 
        return ans if ans != amount+1 else -1
```  

还可以进一步优化，只保留 **代表剩余容量** 的维度。在状态转移过程中，每一行的状态值都**只与其正上方和左方**的状态值有关，因此可对状态空间进一步优化而**省去滚动数组**，在更新 $dp[j]$ 时，仅使用了上行的$dp[j]$ 和本行的 $dp[j-w_i]$   

```python 
class Solution: 
    def coinChange(self, coins: List[int], amount: int) -> int:
        
        dp = [amount+1] * (amount+1)    # 初始化为一个较大的值，如 +inf 或 amount+1
        dp[0] = 0        # 合法的初始化；其他 dp[j]均不合法
        
        # 完全背包：优化后的状态转移
        for coin in coins:                      # 第一层循环：遍历硬币
            for j in range(coin, amount+1):     # 第二层循环：遍历背包【正序】
                dp[j] = min( dp[j], dp[j-coin] + 1 )    # 可选择当前硬币

        ans = dp[amount] 
        return ans if ans != amount+1 else -1
```
注意：在0-1背包问题中，第二层循环是 **逆序**，在完全背包问题中，第二层循环是 **正序**  

多重背包问题：每个物品的选择次数有限制，计算装满的最少硬币个数，<font color="red">**本质上是0-1背包的基础上添加一层硬币个数的循环**</font>.  

常见动态规划问题： 
- [ Fibonacci Number ]( https://leetcode.cn/problems/fibonacci-number/description/ ) 
```python 
class Solution:
    def fib(self, n: int) -> int:  
        if n == 0: return 0 
        dp = [0] * (n+1) 
        # base case 
        dp[0], dp[1] = 0, 1  

        for i in range(2, n+1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]  
```    

- [ Coin Change ]( https://leetcode.cn/problems/coin-change/description/ )   
```python 
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int: 
        n = len(coins) 

        # 初始化为一个较大的值
        dp = [ [amount+1] + [amount+1] for _ in range(n+1) ]  
        # 合法初始化
        dp[0][0] = 0 

        # 完全背包
        for i in range(1, n+1): # 遍历硬币
            for j in range(amount+1): 
                # 遍历背包  
                if j < coins[i-1]: # 若容量有限，无法选择第i种硬币
                    dp[i][j] = dp[i-1][j]  
                else:
                    dp[i][j] = min( dp[i-1][j], dp[i][j-coins[i-1]] + 1)  
```  

- [ Partition Equal Subset Sum ]( https://leetcode.cn/problems/partition-equal-subset-sum/description/ )   
```python  
class Solution:
    def canPartition(self, nums: List[int]) -> bool:  
        n = len(nums)
        m = sum(nums)  
        # if m is odd 
        if m%2:
            return False 
        # let m = m/2 
        m = int(m//2 ) 

        # initalize dp array 
        dp = [[False] * (m+1) for _ in range(n)] 

        dp[0][0] = True 
        for i in range(1, m+1): 
            if nums[0] == 1:
                dp[0][i] = True 
                break 
            
        for i in range(1, n):
            for  j in range(m+1):
                if j>= nums[i]:
                    dp[i][j] = dp[i-1][j] or dp[i-1][j - nums[i]] 
                else:
                    dp[i][j] = dp[i-1][j]                 
        return dp[-1][-1] 
```   

**路径问题** 

- [ Unique Paths ]( https://leetcode.cn/problems/unique-paths/description/ )   
```python  
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:  
        # step1: 构建二维数组, 由于f[0][j] = 1, f[i][0] = 1, 完成初始化
        # step2: 确定状态转移方程：f[i][j] = f[i-1][j] + f[i][j-1] 
        # step3: 返回dp数组的各维度上的最后一个值 f[-1][-1]  

        # f = [[0]*n for _ in range(m)] 
        # for i in range(m):
        #     f[i][0] = 1
        # for j in range(n):
        #     f[0][j] = 1 

        # for i in range(1, m):
        #     for j in range(1, n):
        #         f[i][j] = f[i-1][j] + f[i][j-1] 
        
        # return f[-1][-1]
        
        # 滚动数组 优化 二维数组 
        f = [1] * m 
        for j in range(1, n):
            for i in range(1, m):
                f[i] = f[i-1] + f[i] 
        
        return f[-1]
```   

- [ Unique Paths II ]( https://leetcode.cn/problems/unique-paths-ii/description/ )   
```python  
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:  
        m, n = len(obstacleGrid[0]), len(obstacleGrid) 
        dp = [1] + [0] * m 
        for i in range(0, n):
            for  j in range(0, m):
                if obstacleGrid[i][j]:
                    dp[j] = 0 
                else:
                    dp[j] = dp[j] + dp[j-1]
        return dp[-2] 
```   

- [ Minimum Path Sum ]( https://leetcode.cn/problems/minimum-path-sum/description/ )   
```python  
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int: 
        if not grid: return
        h, w = len(grid), len(grid[0]) 
        # dp[] = [[0] * ]
        for i in range(h):
            for j in range(w):
                if i==0 and j == 0:
                    continue 
                if i==0 and j != 0:
                    grid[i][j] += grid[i][j-1] 
                elif j == 0 and i != 0:
                    grid[i][j] += grid[i-1][j] 
                else:
                    grid[i][j] += min(grid[i-1][j], grid[i][j-1]) 
        return grid[-1][-1]
```   

- [ Path Sum ]( https://leetcode.cn/problems/path-sum/description/ )   
```python  
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool: 
        if not root: 
            return False 
        
        if not root.left and not root.right:
            return targetSum == root.val 
        
        return self.hasPathSum(root.left, targetSum-root.val) or self.hasPathSum(root.right, targetSum-root.val) 
```  

**子序列问题**

DP是解决此类字符串匹配问题的通用解法 

- [ Distinct Subsequences ]( https://leetcode.cn/problems/distinct-subsequences/description/ )   
```python  
class Solution:
    def numDistinct(self, s: str, t: str) -> int:   
        n, m = len(s), len(t) 
        # dp = [[0] * (n+1) for _ in range(m+1)]  
        dp = [0] * (m+1) 
        dp[0] = 1

        for i in range(len(s)):
            for j in range(len(t), 0, -1):
                if s[i] == t[j-1]:
                    dp[j] += dp[j-1] 

        return dp[-1]
```   

编辑距离，经典的DP题目，思路如下：
- 两个指针 i, j从两个字符串末端向前移动，不断比较 
- 如果 word1[j] == word2[i], 则 i,j 分别向前移动，故有 `dp[i][j]=dp[i-1][j-1]` 
- 若 word1[j] != word2[i], 则执行"插入"，"删除", "替换"操作中的一个，即 `dp[i][j] = min( dp[i][j-1]+1 , dp[i-1][j]+1 , dp[i-1][j-1]+1 )`

- [ Edit distance ]( https://leetcode.cn/problems/edit-distance/description/ )   
```python  
class Solution:
    def minDistance(self, word1: str, word2: str) -> int: 
        m = len(word1) 
        n = len(word2) 
        dp = [[0] * (n+1) for _ in range(m+1)] 
        # base case, initialize first row and first column 
        for i in range(1, m+1):
            dp[i][0] = i 
        for j in range(1, n+1):
            dp[0][j] = j  

        for i in range(1, m+1):
            for j in range(1, n+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1] 
                else:
                    dp[i][j] = min(
                        dp[i-1][j] + 1,
                        dp[i][j-1] + 1,
                        dp[i-1][j-1] + 1
                    ) 
        return dp[m][n] 
```  

- [ Longest Common Subsequence]( https://leetcode.cn/problems/longest-common-subsequence/description/ )   
```python  
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int: 
        n, m = len(text1), len(text2) 
        f = [[0] * (m+1) for _ in range(n+1) ] 
        for i, x in enumerate(text1):
            for j, y in enumerate(text2):
                f[i+1][j+1] = f[i][j] + 1 if x == y else max(f[i][j+1],f[i+1][j]) 

        return f[n][m]
``` 




