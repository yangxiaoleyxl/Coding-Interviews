### 双指针技巧 
双指针技巧是 Coding Interviews 中常见的技巧，也是考察很多的技能点。通常分为 **快慢双指针** 和 **左右双指针**，其中 **快慢双指针** 通常是同向而行（多为从数组idx=0到idx=len(nums)-1, 或者 链表头节点 到 链表尾节点 ）。 **左右双指针** 又可以分为 **从中间向两端** 和 **从两端向中间**   

经典题目： 

- [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)
- [Container With Most Water](https://leetcode.com/problems/container-with-most-water/)
- [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)
- [3Sum](https://leetcode.com/problems/3sum/)
- [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)
- [Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/)
- [Valid Palindrome II](https://leetcode.com/problems/valid-palindrome-ii/)
- [Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/)
- [Reverse Pairs](https://leetcode.com/problems/reverse-pairs/)
- [Longest Mountain in Array](https://leetcode.com/problems/longest-mountain-in-array/)
- [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)
- [Sort Colors](https://leetcode.com/problems/sort-colors/)
- [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)
- [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)
- [Merge Intervals](https://leetcode.com/problems/merge-intervals/)
- [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)
- [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)
- [Two Sum II - Input array is sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)
- [Find All Duplicates in an Array](https://leetcode.com/problems/find-all-duplicates-in-an-array/)
- [Longest Word in Dictionary through Deleting](https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/)
- [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)
- [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
- [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)
- [Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements/)
- [Linked List Components](https://leetcode.com/problems/linked-list-components/)
- [Partition Labels](https://leetcode.com/problems/partition-labels/)
- [Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)
- [Minimum Moves to Equal Array Elements II](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/)
- [Minimum Window Subsequence](https://leetcode.com/problems/minimum-window-subsequence/)
- [Shortest Word Distance III](https://leetcode.com/problems/shortest-word-distance-iii/)
- [Shortest Word Distance II](https://leetcode.com/problems/shortest-word-distance-ii/)
- [Shortest Word Distance](https://leetcode.com/problems/shortest-word-distance/)
- [Valid Palindrome III](https://leetcode.com/problems/valid-palindrome-iii/)
- [Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/)
- [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)
- [Minimum Size Subsequence Sum](https://leetcode.com/problems/minimum-size-subsequence-sum/)
- [Minimum Operations to Reduce X to Zero](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/)
- [Minimum Absolute Difference in BST](https://leetcode.com/problems/minimum-absolute-difference-in-bst/)
- [Minimum Distance Between BST Nodes](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)
- [Minimum Moves to Equal Array Elements](https://leetcode.com/problems/minimum-moves-to-equal-array-elements/)
- [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)
- [Minimum Subsequence in Non-Increasing Order](https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/)
- [Minimum Subsequence in Distinct Elements](https://leetcode.com/problems/minimum-subsequence-in-distinct-elements/) 
- [Minimum Increment to Make Array Unique](https://leetcode.com/problems/minimum-increment-to-make-array-unique/)
- [Minimum Domino Rotations For Equal Row](https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/)
- [Minimum Cost to Move Chips to The Same Position](https://leetcode.com/problems/minimum-cost-to-move-chips-to-the-same-position/)
- [Minimum Number of Flips to Convert Binary Matrix to Zero Matrix](https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/)


1. [Minimum Subsequence in Distinct Elements](https://leetcode.com/problems/minimum-subsequence-in-distinct-elements/)   
```python 
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int: 
        if not nums:
            return 
        slow = 0 
        fast = 1
        while fast < len(nums):   
            # if there is a duplicate elemente
            if nums[slow] != nums[fast]:  
                #  keep [0, ... , nums] is unique
                slow += 1   
                nums[slow] = nums[fast]   
            # fast pointer steps forward  
            fast += 1   
        # return the index   
        return slow + 1         
``` 

2. [Reverse linked list ii](https://leetcode.cn/problems/reverse-linked-list-ii/) 
```python 
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def __init__(self):
        self.succesor = None

    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]: 
        if left == 1:
            return self.reverseN(head, right) 
        head.next = self.reverseBetween(head.next, left-1, right-1) 
        return head 

    def reverseN(self, head, n):
        if n == 1:
            self.succesor = head.next 
            return head 

        last = self.reverseN(head.next, n-1) 
        head.next.next = head 
        head.next = self.succesor
        return last  
``` 
3. [Remove elements](https://leetcode.cn/problems/remove-element/description/)    
```python 
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:  
        slow = 0
        fast = 0 
        while fast < len(nums):
            if nums[fast] != val :
                nums[slow] =nums[fast] 
                slow += 1 
            fast += 1 
        
        return slow 
``` 
4. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)   
```python 
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int: 
        if not nums:
            return 
        slow = 0 
        fast = 1
        while fast < len(nums):  
            if nums[slow] != nums[fast]: 
                slow += 1   
                nums[slow] = nums[fast]    
            fast += 1     
        return slow + 1 
```
5. [Remove-nth-node-from-end-of-list](https://leetcode.cn/problems/remove-nth-node-from-end-of-list)    
```python 
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:  
        slow = 0
        fast = 0 
        while fast < len(nums):
            if nums[fast] != val :
                nums[slow] =nums[fast] 
                slow += 1 
            fast += 1 
        
        return slow 
```
6. [3Sum](https://leetcode.cn/problems/3sum)    
```python 
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:   
        nums.sort()
    
        # initialize the result list
        res = []
        
        # iterate over the array
        for i in range(len(nums)):
            # skip over duplicates
            if i > 0 and nums[i] == nums[i-1]:
                continue
            
            # initialize the two pointers
            left = i + 1
            right = len(nums) - 1
            
            # iterate over the remaining elements
            while left < right:
                # calculate the sum of the three elements
                total = nums[i] + nums[left] + nums[right]
                
                # if the sum is less than zero, move the left pointer to the right
                if total < 0:
                    left += 1
                # if the sum is greater than zero, move the right pointer to the left
                elif total > 0:
                    right -= 1
                # if the sum is zero, add the triplet to the result list and move both pointers
                else:
                    res.append([nums[i], nums[left], nums[right]])
                    left += 1
                    right -= 1
                    
                    # skip over duplicates
                    while left < right and nums[left] == nums[left-1]:
                        left += 1
                    while left < right and nums[right] == nums[right+1]:
                        right -= 1
        
        return res 
```
7. [链表中倒数第 K 个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)    
```python 
class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode: 
        fast = head 

        for i in range(k): 
            fast = fast.next 

        slow = head 
        while fast : 
            slow = slow.next
            fast = fast.next 
        
        return slow
```  
8. [ Remove Duplicates from Sorted Array ](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)    
```python 
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int: 
        if not nums:
            return 
        slow = 0 
        fast = 1 
        while fast < len(nums):  
            if nums[slow] != nums[fast]: 
                slow += 1   
                nums[slow] = nums[fast]    
            fast += 1     
        return slow + 1 
``` 
9. [ Remove Duplicates from Sorted List ]( https://leetcode.cn/problems/remove-duplicates-from-sorted-list/ )    
```python 
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 递归法
        # if not head or not head.next: return head 
        # head.next = self.deleteDuplicates(head.next)
        # return head if head.val != head.next.val else head.next  

        # Two pointers 
        if not head or not head.next: return head 
        slow = head 
        fast = head.next 
        while fast:
            if slow.val != fast.val: slow = slow.next 
            else: slow.next = fast.next
            fast = fast.next
        return head  
``` 
10. [Longest Palindromic Substring]( https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/ )    
```python 
class Solution:
    def longestPalindrome(self, s: str) -> str: 
        self.res = ""  

        for i in range(len(s)):
            s1 = self.palindrome(s, i, i)
            s2 = self.palindrome(s, i, i+1)  

            self.res = self.res if len(self.res) > len(s1) else s1
            self.res = self.res if len(self.res) > len(s2) else s2 
        
        return self.res

    def palindrome(self, s, l, r):
        while l >= 0 and r < len(s) and s[l] == s[r]:
            l -= 1 
            r += 1
            
        return s[l+1 : r]  
``` 

